# Author: Pavan Prabhakar Bhat (pxb8715@rit.edu)

from copy import deepcopy

# A variable that is used to display the game board
gameBoard = ""
# Number of rows on the board
rows = 3
# Number of columns on the board
columns = 3
# The current configuration or state of the board
gameBoardList = [[" ", " ", " "], [" ", " ", " "], [" ", " ", " "]]

# Number of nodes generated by Minimax algorithm
noOfNodes = 0

# Current Player
currentPlayer = ""


def getBoard(state):
    '''
    The function takes the values from gameBoardList as input and returns a visual board with the current configuration state
    :return: Returns a String displaying the current state of the Board
    '''
    gameBoard = ""
    for i in range(rows):
        for j in range(columns):
            if j < (columns - 1):
                gameBoard += state[i][j].upper() + " | "
            else:
                gameBoard += state[i][j].upper()
        if i < (rows - 1):
            gameBoard += '\n'
            gameBoard += "-" * 9
            gameBoard += '\n'
        else:
            gameBoard += '\n'
    print(gameBoard)


def movesLeft(state):
    '''
    The function is a check to find whether there are any moves possible on the Tic-Tac-Toe board with its current configuration
    :return: Returns a boolean value i.e. either True or False
    '''
    for i in range(rows):
        for j in range(columns):
            # Checks to see if any slots are empty
            if state[i][j] == " ":
                return True
    return False


def calculateUtility(state):
    '''
    This function calculates the utility of the current board configuration
    :return: Utility value i.e. either +1 (max wins), -1 (max looses) or 0 (max ties)
    '''
    # Checking all columns for a win or lose configuration
    if state[0][0] == state[1][0] == state[2][0] == "X":
            return 10
    if state[0][1] == state[1][1] == state[2][1] == "X":
            return 10
    if state[0][2] == state[1][2] == state[2][2] == "X":
            return 10
    elif state[0][0] == state[1][0] == state[2][0] == "O":
            return -10
    elif state[0][1] == state[1][1] == state[2][1] == "O":
            return -10
    elif state[0][2] == state[1][2] == state[2][2] == "O":
            return -10
    elif state[0][0] == state[0][1] == state[0][2] == "X":
            return 10
    elif state[1][0] == state[1][1] == state[1][2] == "X":
            return 10
    elif state[2][0] == state[2][1] == state[2][2] == "X":
            return 10
    elif state[0][0] == state[0][1] == state[0][2] == "O":
            return -10
    elif state[1][0] == state[1][1] == state[1][2] == "O":
            return -10
    elif state[2][0] == state[2][1] == state[2][2] == "O":
            return -10
    elif state[0][0] == state[1][1] == state[2][2] == "X":
            return 10
    elif state[0][2] == state[1][1] == state[2][0] == "O":
            return -10
    elif state[0][0] == state[1][1] == state[2][2] == "O":
            return -10
    elif state[0][2] == state[1][1] == state[2][0] == "X":
            return 10
    elif " " in [state[0][0], state[0][1], state[0][2],
                 state[1][0], state[1][1], state[1][2],
                 state[2][0], state[2][1], state[2][2]]:
            return 2
    else:
            return 0




def minimaxDecision(state, player):
    '''
    The main crux of the minimax algorithm exists in this function and returns the intelligent option from the computer
    :param state: current state of the board
    :param player: current player
    :return:
    '''
    global noOfNodes
    # Check to see if the minimax algorithm terminates, returns state and utility
    calculatedUtility = calculateUtility(state)
    if calculatedUtility in [10, -10, 0]:
        return calculatedUtility, state

    # Switches between the player and the computer
    if player.lower() == "X".lower():
        currentPlayer = "O"
    else:
        currentPlayer = "X"


    # Obtains a list of successors for each branch
    mainSuccessorList = successors(state, player)
    tempValue1 = []

    # Iterates over the successor list and performs the minimax conditions
    for s in mainSuccessorList:
        # Updates the number of nodes in the search tree
        noOfNodes += 1
        v, state = minimaxDecision(s, currentPlayer)
        tempValue1.append(v)

    # If the user is playing it will store the utility values after a depth first search and will return the max utility and the states of the list
    if player == "X":
        maxUtility = max(tempValue1)
        for i in range(len(tempValue1)):
            if maxUtility == tempValue1[i]:
                maxPosition = i
        return maxUtility, mainSuccessorList[maxPosition]
    # If the computer is playing it will store the utility values after a depth first search and will return the max utility and the states of the list
    elif player == "O":
        minUtility = min(tempValue1)
        for j in range(len(tempValue1)):
            if minUtility == tempValue1[j]:
                minPosition = j
        return minUtility, mainSuccessorList[minPosition]

def successors(state, player):
    '''
    Returns a list of successve states
    :param state: current configuration of the board
    :param player: current player
    :return:
    '''
    listOfSuccessors = []
    for i in range(3):
        for j in range(3):
            if state[i][j] == " ":
                temp = deepcopy(state)
                temp[i][j] = player
                listOfSuccessors.append(temp)
    return listOfSuccessors


#########################
# Main program
#########################
def main():
    '''
    Runs the main program to play the Tic Tac Toe
    :return: None
    '''
    global gameBoardList, noOfNodes
    flag = True
    while(flag):
        userReady = input("Are you ready to play Tic-Tac-Toe? (Y/N)")
        if(userReady.lower() == 'y'):
             break
        else:
           print("Come back when you are ready to play with the master!")


    user = "X"
    computer = "O"
    getBoard(gameBoardList)
    print("")

    while True:
        utility = calculateUtility(gameBoardList)
        if utility in [10, -10, 0]:
            if(utility == 10):
                print("Player wins the game!")
            elif(utility == -10):
                print("Computer wins the game!")
            else:
                print("Its a draw")
            break
        r = int(input("Enter row number: "))
        c = int(input("Enter column number: "))
        if gameBoardList[r][c] is not " ":
            print("Place already taken! Kindly enter again--")
            continue
        gameBoardList[r][c] = user
        getBoard(gameBoardList)
        print()

        # Number of node re-initiated for the search tree
        noOfNodes = 0

        v, gameBoardList = minimaxDecision(gameBoardList, computer)
        getBoard(gameBoardList)
        print()
        print("Number of Search Tree nodes generated: ", noOfNodes)



# Execute the main program.
main()
